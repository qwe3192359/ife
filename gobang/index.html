<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        .can {
            border: 1px solid #eee;
        }
    </style>
</head>
<body>
<canvas id="can" class="can" width="500" height="500"></canvas>
<script>
    (function () {
        //获取canvas元素
        let drawing = document.getElementById('can');
        //判断浏览器是否可以使用canvas
        if (drawing.getContext) {

        }
    })();

    //获取canvas元素
    let drawing = document.getElementById('can');
    //当前执行黑棋还是白棋
    let man = true;
    //棋子数组
    let piecesArray = [],
        whitePiecesArray = [],
        blackPiecesArray = [];

    //棋盘上的点击事件
    drawing.onclick = function (e) {
        console.log(e);
        //点击的位置在棋盘的几行几列
        let x = Math.round((e.offsetX - 20) / 30);
        let y = Math.round((e.offsetY - 20) / 30);
        //如果当前位置已有棋子则不能落子
        for(let i = 0;i<piecesArray.length;i++){
            if(piecesArray[i][0] === x && piecesArray[i][1] === y){
                return
            }
        }
        //只能在棋盘内落子
        if( x>=0 && x<15 && y>=0 && y<15 ){
            piece(x, y, man);
        }

    };

    //画布环境
    let con = drawing.getContext('2d');
    con.strokeStyle = '#eee';    //描边矩形颜色

    con.beginPath();    //开始路径
    con.translate(20, 20);   //移动坐标原点
    //绘制棋盘
    for (let i = 0; i < 15; i++) {
        con.moveTo(0, i * 30);
        con.lineTo(420, i * 30);
        con.stroke();
    }
    for (let i = 0; i < 15; i++) {
        con.moveTo(i * 30, 0);
        con.lineTo(i * 30, 420);
        con.stroke();
    }
    //落子
    function piece(x, y) {
        //白棋棋子渐变
        let black = con.createRadialGradient(x * 30, y * 30, 5, x * 30, y * 30, 15);
        black.addColorStop(0, '#0a0a0a');
        black.addColorStop(1, '#666');
        //黑棋棋子渐变
        let white = con.createRadialGradient(30, 30, 5, 30, 30, 15);
        white.addColorStop(0, '#f9f9f9');
        white.addColorStop(1, '#d1d1d1');
        //当前落子为黑棋还是白棋
        if (man) {
            con.fillStyle = white;
            man = false;
            //保存棋子
            piecesArray.push([x,y]);
            whitePiecesArray.push([x,y]);
        }
        else {
            con.fillStyle = black;
            man = true;
            //保存棋子
            piecesArray.push([x,y]);
            blackPiecesArray.push([x,y]);
        }
        //绘制棋子
        con.beginPath();
        con.arc(x * 30, y * 30, 14, 0, 2 * Math.PI, false);
        con.fill();

        victory();
    }
    //胜负判定
    function victory(){
        //将黑、白棋数组保存在新的数组里
        let newWhitePiecesArray = whitePiecesArray.concat();
        let newBlackPiecesArray = blackPiecesArray.concat();
        if(newWhitePiecesArray.length < 5){
            return
        }

        if( verticalWin(newWhitePiecesArray) || acrossWin(newWhitePiecesArray) ){
            console.log('白棋胜利');
            history.go(0);
            alert('白棋胜利');

        }
        else if(verticalWin(newBlackPiecesArray) || acrossWin(newBlackPiecesArray) ){
            console.log('黑棋胜利');
            history.go(0);
            alert('黑棋胜利');

        }



    }
    //按照竖排排序，从左到右，从上到下
    function verticalSort(arr) {
        arr.sort(function (a,b) {
            if(a[0] > b[0]){
                return 1
            }
            else if (a[0] === b[0] && a[1] > b[1]){
                return 1
            }
            else{
                return -1
            }
        });
        return arr
    }
    //按照横排排序，从上到下，从左到右
    function acrossSort(arr) {
        arr.sort(function (a,b) {
            if(a[1] > b[1]){
                return 1
            }
            else if (a[1] === b[1] && a[0] > b[0]){
                return 1
            }
            else{
                return -1
            }
        });
        return arr
    }
    //竖排排序后胜负判断
    function verticalWin(arr){
        arr = verticalSort(arr);
        //竖排胜利
        let j = 0;
        for(let i = 0; i < arr.length - 1;i++){
            if(arr[i][0] === arr[i+1][0] && arr[i][1] + 1 === arr[i+1][1]){
                j++;
                if(j === 4){
                    console.log('胜利');
                    return true
                }
            }
            else{
                j = 0;
            }
        }

        //斜排胜利
        let k = 1;
        for(let i = 0; i < arr.length - 1;i++){
            for(let j = 1;j < arr.length;j++){
                if(arr[i][0]+k === arr[j][0] && arr[i][1]+k === arr[j][1]){
                    k++;
                    if(k === 5){
                        console.log('胜利');
                        return true
                    }
                }
                else{
                    k = 1
                }
            }
        }

    }
    //横排排序后胜负判断
    function acrossWin(arr){
        arr = acrossSort(arr);
        //横排胜利
        let j = 0;
        for(let i = 0; i < arr.length - 1;i++){
            if( arr[i][1] === arr[i+1][1] && arr[i][0] + 1 === arr[i+1][0] ){
                j++;
                if(j === 4){
                    console.log('胜利');
                    console.log(arr)
                    return true
                }
            }
            else{
                j = 0;
            }
        }

        //反斜排胜利
        let k = 1;
        for(let i = 0; i < arr.length - 1;i++){
            for(let j = 1;j < arr.length;j++){
                if(arr[i][1]+k === arr[j][1] && arr[i][0]-k === arr[j][0]){
                    k++;
                    if(k === 5){
                        console.log('胜利');
                        return true
                    }
                }
                else{
                    k = 1
                }
            }
        }
    }
</script>
</body>
</html>